### slide::
# We begin with a Table object
from sqlalchemy import MetaData, Table, Column, String, Integer

metadata = MetaData()
user_table = Table('user', metadata, 
            Column('id', Integer, primary_key=True),
            Column('username', String(50)),
            Column('fullname', String(50))
)

### slide:: -*- no_exec -*-
# Then we'll create a new SQLite database and generate the table.

from sqlalchemy import create_engine
engine = create_engine("sqlite://")
metadata.create_all(engine)

### slide::
# as we saw earlier, Table has a collection of Column objects,
# which we can access via table.c.<columnname>

user_table.c.username


### slide::
# the Column object is part of a class of objects known as 
# "clause elements".   These objects have special behavior in Python
# expressions, making use of Python's ability to "overload" operators
# such as "==", "!=", etc. to produce a special kind of object.

expression = user_table.c.username == 'ed'

### slide:: -*-no_clear-*-
# the comparison object we just got is itself a "clause element".
expression

### slide:: -*-no_clear-*-
# this object, when evaluated as a string, becomes a SQL string.
print expression

### slide::
# Each new clause element can be further transformed into a more complex
# SQL expression, such as here using the | operator
# to produce OR:

print (user_table.c.username == 'ed') | (user_table.c.username == 'jack')

### slide::
# OR and AND are often produced using the or_() and and_() constructs 
# explicitly

from sqlalchemy import and_, or_

print and_(
    user_table.c.fullname == 'ed jones', 
        or_(
            user_table.c.username == 'ed', 
            user_table.c.username == 'jack'
        )
    )

### slide::
# comparison operators like <, >..

print user_table.c.id > 5

### slide::
# Compare to None produces IS NULL

print user_table.c.fullname == None

### slide::
# math operations...

print user_table.c.id + 5

### slide:: -*-no_clear-*-
# ...or string concatenation

print user_table.c.fullname + "some name"

### slide::
# an IN

print user_table.c.username.in_(["wendy", "mary", "ed"])

### slide::
# The result of any expression is an object that represents instructions
# for how to generate a SQL string.

expression = user_table.c.username == 'ed'
expression

### slide::
# The expression object has a method called *compile()* which transforms the expression
# construct into a "baked" format that is specific to a certain kind 
# of database.  We normally do not have to call this method explicitly.

from sqlalchemy.dialects import mysql
compiled = expression.compile(dialect=mysql.dialect())

### slide:: -*- no_clear -*-
# MySQL compilation...
print compiled

### slide:: -*- no_clear -*-
# PostgreSQL compilation...
from sqlalchemy.dialects import postgresql
compiled = expression.compile(dialect=postgresql.dialect())
print compiled

### slide::
# The main thing the Compiled object does is create the SQL string...

compiled.string

### slide:: -*- no_clear -*-
# but it also has the "bound parameters" from our original statement
# contained within it.
compiled.params

### slide::
# the Engine/Connection do the work of handling the "compile" step 
# and the parameters when we pass a fully formed SQL expression construct
# to the execute() method.

engine.execute(user_table.select().where(user_table.c.username == 'ed'))

### slide::
# let's put some data into the database.  We'll use an insert() 
# statement, which we can usually get from the Table object directly:

insert_stmt = user_table.insert().values(username='ed', fullname='ed jones')
print insert_stmt

### slide:: -*- no_exec -*-
# we pass the statement to execute() to run it.  This time we use a Connection
# object.

conn = engine.connect()
result = conn.execute(insert_stmt)

### slide:: 
# when we INSERT a single row using an insert() construct, we usually can
# get at the primary key for the row from the result.  Surrogate
# primary keys are usually generated by the database for us.
print result.inserted_primary_key

### slide:: -*- no_exec -*-
# INSERT operations can also run multiple parameter sets in at once, if we 
# leave off the "values()" part and just add the parameters to execute.
# This runs *much* faster for large sets of data.

conn.execute(user_table.insert(), [
    {'username':'jack', 'fullname':'Jack Burger'},
    {'username':'wendy', 'fullname': 'Wendy Williams'}
])

### slide:: -*- no_exec -*-
# This is a free-standing select() statement.  Unlike table.select(),
# we can control which columns to select.   Here we can see our new row
# which has just been inserted.

from sqlalchemy import select
select_stmt = select([user_table.c.username, user_table.c.fullname]).\
            where(user_table.c.username == 'ed')
result = conn.execute(select_stmt)

### slide:: -*- no_clear -*-

for row in result:
    print row

### slide:: 
# some demos of select().   We can select the whole table's columns
# by passing it in as the argument:

select_stmt = select([user_table])
print conn.execute(select_stmt).fetchall()


### slide:: 
# the WHERE method accepts any expression, including conjunctions
# like AND and OR

select_stmt = select([user_table]).\
                    where(
                        or_(
                            user_table.c.username=='ed', 
                            user_table.c.username=='wendy'
                        )
                    )
print conn.execute(select_stmt).fetchall()

### slide:: 
# WHERE can be called repeatedly, these predicates are joined
# by AND.  This pattern is called "method chaining", in SQLAlchemy
# we call it "generative".

select_stmt = select([user_table]).\
                    where(user_table.c.username=='ed').\
                    where(user_table.c.fullname=='ed jones')
print conn.execute(select_stmt).fetchall()

### slide:: 
# ordering is applied using order_by()

select_stmt = select([user_table]).\
                    order_by(user_table.c.username)
print conn.execute(select_stmt).fetchall()

### slide:: 
# the text() construct is used to work with strings directly

from sqlalchemy import text
text_stmt = text("select * from user where username=:name")
print text_stmt

### slide:: -*-no_clear-*-
# the bound parameters are converted to the right format 
# when we execute()
print conn.execute(text_stmt, name="ed").fetchall()

### slide:: -*- no_exec -*-
# to briefly illustrate joins and foreign keys, let's create another table
# that refers to the "user" table
from sqlalchemy import ForeignKey

address_table = Table("address", metadata,
                    Column('id', Integer, primary_key=True),
                    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
                    Column('email_address', String(100), nullable=False)
                )
metadata.create_all(engine)

conn.execute(address_table.insert(), [
    {"user_id":1, "email_address":"ed@ed.com"},
    {"user_id":1, "email_address":"ed@gmail.com"},
    {"user_id":2, "email_address":"jack@yahoo.com"},
    {"user_id":3, "email_address":"wendy@gmail.com"},
])

### slide::
# we now have two Table objects.   If we wanted to select from both, we 
# can use a join:
#
# <left>.join(<right>, [<onclause>]).

join_obj = user_table.join(address_table, user_table.c.id==address_table.c.user_id)
print join_obj

### slide::
# Because we made our address_table using a ForeignKey object, SQLAlchemy
# already knows how these tables should be joined, so we can omit the "on clause"

join_obj = user_table.join(address_table)
print join_obj

### slide:: -*- no_exec -*-
# now to illustrate our JOIN inside of a SELECT.   We can select all columns
# from both tables.

select_stmt = select([user_table, address_table]).select_from(join_obj)
result = conn.execute(select_stmt)
print result.fetchall()

### slide::
# The true nature of SQLAlchemy is centered on its idea of a "selectable".
# In SQL, we can select rows from tables, but also from SELECT statements.
# So the select() object has a .c. attribute just like Table !

select_stmt = select([user_table]).where(user_table.c.username=='ed')

print select([select_stmt.c.username]).where(select_stmt.c.username=='ed')

### slide::
# Though usually, when selecting from a SELECT, we need to "alias" it, which 
# gives it a name when used as a subquery.  Most databases want us to do this:

select_alias = select_stmt.alias()
print select([select_alias.c.username]).where(select_alias.c.username=='ed')

### slide::
# To show how this is often used, we'll show how to get usernames and the number
# of email addresses they have, using COUNT and GROUP BY

from sqlalchemy import func
address_subq = select([
                    address_table.c.user_id, 
                    func.count(address_table.c.id).label('count')
                ]).\
                group_by(address_table.c.user_id).\
                alias()
print address_subq

### slide:: -*- no_clear -*-
print conn.execute(address_subq).fetchall()

### slide::
# With our "selectable" representing user ids and counts, we can combine
# it with the "user" table using JOIN.   

username_plus_count = select([user_table.c.username, address_subq.c.count]).\
                       select_from(
                          user_table.join(address_subq)
                       ).\
                       order_by(user_table.c.username)

### slide:: -*- no_clear -*-

conn.execute(username_plus_count).fetchall()

### slide::
# a *scalar select* is a select statment that returns exactly one row and
# one column, and can be used as a column expression.

address_sel = select([
                func.count(address_table.c.id)
                ]).\
                where(user_table.c.id==address_table.c.user_id)
print address_sel

### slide:: -*-no_clear -*-
# as_scalar() is used for *correlated selects*.

select_stmt = select([user_table.c.username, address_sel.as_scalar()])
print conn.execute(select_stmt).fetchall()

### slide:: -*-no_exec -*-
# to round out INSERT and SELECT, this is an UPDATE

update_stmt = address_table.update().\
                    values(email_address="jack@msn.com").\
                    where(address_table.c.email_address=="jack@yahoo.com")

result = conn.execute(update_stmt)

### slide:: -*-no_clear -*-
# UPDATE and DELETE have a "rowcount", number of rows matched
# by the WHERE clause.
result.rowcount

### slide:: -*-no_exec -*-
# an UPDATE can also use expressions based on other columns

update_stmt = user_table.update().\
                    values(fullname = user_table.c.username + " | " + user_table.c.fullname)

result = conn.execute(update_stmt)

### slide:: -*-no_clear -*-
conn.execute(select([user_table])).fetchall()

### slide:: -*-no_exec -*-
# and this is a DELETE

delete_stmt = address_table.delete().\
                where(address_table.c.email_address=="ed@ed.com")

result = conn.execute(delete_stmt)

### slide:: -*-no_clear -*-
# UPDATE and DELETE have a "rowcount", number of rows matched
# by the WHERE clause.
result.rowcount

### slide::
